<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lean4 タクティク逆引きリスト</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Lean4 タクティク逆引きリスト</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="aesop.html">aesop: ルーチン自動化</a></li><li class="chapter-item expanded "><a href="apply.html">apply: 含意→を使う</a></li><li class="chapter-item expanded "><a href="apply_question.html">apply?: ライブラリ検索</a></li><li class="chapter-item expanded "><a href="assumption.html">assumption: 仮定をそのまま使う</a></li><li class="chapter-item expanded "><a href="by_cases.html">by_cases: 排中律</a></li><li class="chapter-item expanded "><a href="by_contra.html">by_contra: 背理法</a></li><li class="chapter-item expanded "><a href="by.html">by: タクティクモードに入る</a></li><li class="chapter-item expanded "><a href="calc.html">calc: 計算モードに入る</a></li><li class="chapter-item expanded "><a href="cases.html">cases: 論理和∨を使う</a></li><li class="chapter-item expanded "><a href="choose.html">choose: ∀x∃yP(x,y)から写像を作る</a></li><li class="chapter-item expanded "><a href="constructor.html">constructor: 論理積∧を示す</a></li><li class="chapter-item expanded "><a href="contradiction.html">contradiction: 矛盾</a></li><li class="chapter-item expanded "><a href="conv.html">conv: 変換モードに入る</a></li><li class="chapter-item expanded "><a href="convert.html">convert: 惜しい補題を使う</a></li><li class="chapter-item expanded "><a href="done.html">done: 証明終了を宣言</a></li><li class="chapter-item expanded "><a href="exact.html">exact: 証明を直接構成</a></li><li class="chapter-item expanded "><a href="exists.html">exists: 存在∃を示す</a></li><li class="chapter-item expanded "><a href="ext.html">ext: 外延性を使う</a></li><li class="chapter-item expanded "><a href="funext.html">funext: 関数等式を示す</a></li><li class="chapter-item expanded "><a href="have.html">have: 補題を用意する</a></li><li class="chapter-item expanded "><a href="induction.html">induction: 帰納法</a></li><li class="chapter-item expanded "><a href="intro.html">intro: 含意→や全称∀を示す</a></li><li class="chapter-item expanded "><a href="left_right.html">left, right: 論理和∨を示す</a></li><li class="chapter-item expanded "><a href="linarith.html">linarith: 線形不等式を示す</a></li><li class="chapter-item expanded "><a href="rel.html">rel: 不等式を使う</a></li><li class="chapter-item expanded "><a href="rfl.html">rfl: 定義そのまま</a></li><li class="chapter-item expanded "><a href="ring.html">ring: 環の等式を示す</a></li><li class="chapter-item expanded "><a href="rw.html">rw: 同値変形</a></li><li class="chapter-item expanded "><a href="show.html">show: 示すべきことを宣言</a></li><li class="chapter-item expanded "><a href="simp.html">simp: 簡約</a></li><li class="chapter-item expanded "><a href="sorry.html">sorry: 証明したことにする</a></li><li class="chapter-item expanded "><a href="suffices.html">suffices: 十分条件に帰着</a></li><li class="chapter-item expanded "><a href="trivial.html">trivial: 自明</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean4 タクティク逆引きリスト</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/lean-ja/tactic-cheetsheet" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lean4-タクティク逆引きリスト"><a class="header" href="#lean4-タクティク逆引きリスト">Lean4 タクティク逆引きリスト</a></h1>
<p>「普段の数学を Lean でどうやって実現するんだろう」という疑問に答えるために，よく使うタクティクをユースケースから逆引きできるようにまとめたリストです．</p>
<p>なお，タクティクの説明に付記している名前の由来についての説明は公式に説明があったものではなく，あくまで憶測であることをお断りしておきます．</p>
<h2 id="リンク集"><a class="header" href="#リンク集">リンク集</a></h2>
<p>参考にさせていただいたページをここに列挙します．</p>
<ul>
<li>
<p><a href="https://github.com/haruhisa-enomoto/mathlib4-all-tactics/blob/main/all-tactics.md">mathlib4-all-tactics</a> 全タクティクの網羅的なリスト．</p>
</li>
<li>
<p><a href="https://github.com/yuma-mizuno/lean-math-workshop">数学系のためのLean勉強会</a> いくつかコード例を拝借させていただきました．</p>
</li>
<li>
<p><a href="https://www.ma.imperial.ac.uk/~buzzard/xena/formalising-mathematics-2023/Part_C/Part_C.html">Formalizing Mathematics</a> Lean3 による例ですが，よく使うタクティクを平易な解説とともに紹介しているリストです．</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aesop"><a class="header" href="#aesop">aesop</a></h1>
<p>needs: <code>import Aesop</code></p>
<p><code>aesop</code> は，<code>intro</code> や <code>simp</code> を使用してルーチンな証明を自動で行おうとします．</p>
<pre><code class="language-lean">-- 合成 `g ∘ f` が単射なら，`f` も単射
example {f : X → Y} {g : Y → Z} (hgfinj : Injective (g ∘ f)) : Injective f := by
  rw [Injective]
  aesop
</code></pre>
<h2 id="aesop-1"><a class="header" href="#aesop-1">aesop?</a></h2>
<p><code>aesop</code> が成功したとき，<code>aesop?</code> に置き換えると，ゴールを達成するのにどんなタクティクを使用したか教えてくれます．</p>
<pre><code class="language-lean">example {f : X → Y} {g : Y → Z} (hgfinj : Injective (g ∘ f)) : Injective f := by
  rw [Injective]
  -- `aesop?` は以下を返す
  intro a₁ a₂ a
  apply hgfinj
  simp_all only [comp_apply]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apply"><a class="header" href="#apply">apply</a></h1>
<p><code>apply</code> は含意 <code>→</code> をゴールに適用するタクティクです．</p>
<p>ゴールが <code>⊢ Q</code> で，ローカルコンテキストに <code>h: P → Q</code> があるときに，<code>apply h</code> を実行するとゴールが <code>⊢ P</code> に書き換わります．</p>
<pre><code class="language-lean">-- `P → Q` かつ `P` ならば `Q`
example (h: P → Q) (hP: P) : Q := by
  apply h

  -- ゴールが `P` に変わっている
  show P

  exact hP
</code></pre>
<p>注意点として，<code>h: P → Q</code> は <code>P</code> の証明を受け取って <code>Q</code> の証明を返す関数でもあるので，上記の例は <code>apply</code> を使わずに <code>exact h hP</code> で閉じることもできます．</p>
<pre><code class="language-lean">-- `P → Q` かつ `P` ならば `Q`
example (h: P → Q) (hP: P) : Q := by
  exact h hP
</code></pre>
<h2 id="否定--について"><a class="header" href="#否定--について">否定 ¬ について</a></h2>
<p>また，Lean では否定 <code>¬ P</code> は <code>P → False</code> として実装されているため，ゴールが <code>⊢ False</code> であるときに <code>hn: ¬P</code> に対して <code>apply hn</code> とするとゴールが <code>⊢ P</code> に書き換わります．</p>
<pre><code class="language-lean">-- 矛盾
example (hn: ¬ P) (hP: P) : False := by
  -- ゴールが `P` に変わる
  apply hn

  exact hP
</code></pre>
<h2 id="よくあるエラー"><a class="header" href="#よくあるエラー">よくあるエラー</a></h2>
<p><code>apply</code> には引数が必須なのですが，省略しても近くにエラーが出ません．一般に，構文的に間違った証明を書いた場合には，エラーがわかりやすい場所に出てくれる保証はありません．</p>
<h2 id="関連するタクティク"><a class="header" href="#関連するタクティク">関連するタクティク</a></h2>
<h3 id="exact"><a class="header" href="#exact"><a href="./exact.html">exact</a></a></h3>
<p><code>exact</code> の代わりに <code>apply</code> を使うことができます．</p>
<pre><code class="language-lean">-- `P → Q` かつ `P` ならば `Q`
example (h: P → Q) (hP: P) : Q := by
  apply h
  apply hP
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apply-1"><a class="header" href="#apply-1">apply?</a></h1>
<p>needs: <code>import Mathlib.Tactic.LibrarySearch</code></p>
<p><code>apply?</code> は，ゴールを閉じるのに必要な命題をライブラリから検索してきて，提案してくれるタクティクです．</p>
<pre><code class="language-lean">-- 群準同型は積を保つ
example [Group G] [Group H] (f : G →* H) (a b : G) :
    f (a * b) = f a * f b := by
    -- `exact MonoidHom.map_mul f a b` を提案してくれる
    apply?
</code></pre>
<p>複数の候補が提案されたときは，どれを選ぶとゴールが何に変わるのか表示されるので，その中から好ましいものを選ぶと良いでしょう．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assumption"><a class="header" href="#assumption">assumption</a></h1>
<p><code>assumption</code> は，現在のゴール <code>⊢ P</code> がローカルコンテキストにあるとき，ゴールを閉じます．</p>
<pre><code class="language-lean">example (hP: P) (_: Q) : P := by
  assumption
</code></pre>
<h2 id="関連するタクティク-1"><a class="header" href="#関連するタクティク-1">関連するタクティク</a></h2>
<h3 id="exact-1"><a class="header" href="#exact-1"><a href="./exact.html">exact</a></a></h3>
<p><code>assumption</code> による証明は，どの仮定を使うか明示すれば <code>exact</code> で書き直すことができます．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="by_cases"><a class="header" href="#by_cases">by_cases</a></h1>
<p><code>by_cases</code> は排中律を使って場合分けをするタクティクです．</p>
<p><code>by_cases h: P</code> とすると，<code>P</code> が成り立つときと成り立たないときのゴールがそれぞれ生成されます．</p>
<pre><code class="language-lean">example (P: Prop) : ¬¬P → P := by
  intro hnnP

  -- `P` が成り立つかどうかで場合分けする
  by_cases hP: P

  case inl =&gt;
    -- `P` が成り立つとき
    guard_hyp hP : P

    assumption

  case inr =&gt;
    -- `¬ P` が成り立つとき
    guard_hyp hP : ¬P

    contradiction
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="by_contra"><a class="header" href="#by_contra">by_contra</a></h1>
<p>needs: <code>import Mathlib.Tactic.ByContra</code></p>
<p><code>by_contra</code> は，背理法を使いたいときに役立つタクティクです．</p>
<p>ゴールが <code>⊢ P</code> であるときに <code>by_contra h</code> を実行すると，<code>h : ¬ P</code> がローカルコンテキストに追加されて，同時にゴールが <code>⊢ False</code> になります．</p>
<pre><code class="language-lean">example (h: ¬Q → ¬P) : P → Q := by
  -- `P` であると仮定する
  intro hP

  -- `¬Q` であると仮定して矛盾を導きたい
  by_contra hnQ
  show False

  -- `¬ Q → ¬ P` と `¬Q` から `¬P` が導かれる
  have := h hnQ

  -- これは仮定に矛盾
  contradiction
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="by"><a class="header" href="#by">by</a></h1>
<p>型理論においては，命題 <code>P</code> は型で，証明 <code>h : P</code> はその項です．証明を構成するとは項 <code>h</code> を構成するということです．<code>by</code> は，証明の構成をタクティクで行いたいときに使います．</p>
<pre><code class="language-lean">-- `P → R` というのは `P` の証明を与えられたときに `R` の証明を返す関数の型
-- したがって，その証明は関数となる
example (hPQ : P → Q) (hQR : Q → R) : P → R :=
  fun hP ↦ hQR (hPQ hP)


-- 同じ命題をタクティクで示した例
example (hPQ : P → Q) (hQR : Q → R) : P → R := by
  intro hP
  exact hQR (hPQ hP)
</code></pre>
<h2 id="by-1"><a class="header" href="#by-1">by?</a></h2>
<p>needs: <code>import Std.Tactic.ShowTerm</code></p>
<p><code>by?</code> を使うとタクティクモードで構成した証明を直接構成した証明に変換してくれます．</p>
<pre><code class="language-lean">example (hPQ : P → Q) (hQR : Q → R) : P → R := by?
  -- `Try this: fun hP =&gt; hQR (hPQ hP)` と提案してくれる
  intro hP
  exact hQR (hPQ hP)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calc"><a class="header" href="#calc">calc</a></h1>
<p><code>calc</code> は計算モードに入るためのタクティクです．詳細については<a href="https://aconite-ac.github.io/theorem_proving_in_lean4_ja/quantifiers_and_equality.html#calculational-proofs-%E8%A8%88%E7%AE%97%E7%9A%84%E8%A8%BC%E6%98%8E">Theorem Proving in Lean4</a>をご参照ください．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cases"><a class="header" href="#cases">cases</a></h1>
<p><code>cases</code> は場合分けを行います．ローカルコンテキストに <code>h: P ∨ Q</code> があるときに <code>cases h</code> とすると，仮定に <code>P</code> を付け加えたゴール <code>inl</code> と，仮定に <code>Q</code> を付け加えたゴール <code>inr</code> を生成します．それぞれ，<code>insert left</code> と <code>insert right</code> の略ではないかと思います．</p>
<pre><code class="language-lean">example : P ∨ Q → (P → R) → (Q → R) → R := by
  -- `h: P ∨ Q`
  intro h hPR hQR

  -- `case inl` と `case inr` の２つのゴールを生成する
  cases h

  -- `P` が成り立つ場合
  case inl hP =&gt;
    exact hPR hP

  -- `Q` が成り立つ場合
  case inr hQ =&gt;
    exact hQR hQ
</code></pre>
<h2 id="case-を書かない"><a class="header" href="#case-を書かない">case を書かない</a></h2>
<p>上記の例では <code>case</code> を場合分けの枝ごとに書いていますが，下の例のように <code>case</code> を書かずに済ませることもできます．</p>
<pre><code class="language-lean">example : P ∨ Q → (P → R) → (Q → R) → R := by
  -- `h: P ∨ Q`
  intro h hPR hQR

  -- `case inl` と `case inr` の２つのゴールを生成する
  cases h with
  | inl hP =&gt;
    exact hPR hP
  | inr hQ =&gt;
    exact hQR hQ
</code></pre>
<h2 id="cases-1"><a class="header" href="#cases-1">cases'</a></h2>
<p>needs: <code>import Mathlib.Tactic.Cases</code></p>
<p><code>cases'</code> を使用すると分解した仮定に簡潔に名前をつけることができます．</p>
<pre><code class="language-lean">example : P ∨ Q → (P → R) → (Q → R) → R := by
  intro h hPR hQR

  -- 場合分けをする
  cases' h with hP hQ
  · apply hPR hP
  · apply hQR hQ
</code></pre>
<h2 id="rcases"><a class="header" href="#rcases">rcases</a></h2>
<p>needs: <code>import Std.Tactic.RCases</code></p>
<p>named after: 再帰的(recursive) cases</p>
<p><code>rcases</code> は <code>cases</code> をパターンに従って再帰的に適用します．論理和∨以外にも使うことができます．</p>
<pre><code class="language-lean">variable (P Q R : Prop)

example : P ∨ Q → (P → R) → (Q → R) → R := by
  intro h hPR hQR

  -- 場合分けをする
  rcases h with hP | hQ
  · apply hPR hP
  · apply hQR hQ

example : P ∧ Q → Q ∧ P := by
  -- `h: P ∧ Q` と仮定する
  intro h

  -- `h: P ∧ Q` を `hP: P` と `hQ: Q` に分解する
  rcases h with ⟨hP, hQ⟩

  -- `Q ∧ P` を証明する
  exact ⟨hQ, hP⟩
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="choose"><a class="header" href="#choose">choose</a></h1>
<p>needs: <code>import Mathlib.Tactic.Choose</code></p>
<p><code>h : ∀ x, ∃ y, P(x, y)</code> が成り立っているときに，<code>choose f hf using h</code> は写像 <code>f: X → Y</code> と <code>f</code> が満たす性質 <code>hf : ∀ x, P(x, f x)</code> のペアを作ります．</p>
<pre><code class="language-lean">example (f : X → Y) (hf : ∀ y, ∃ x, f x = y) : ∃ g : Y → X, ∀ y, f (g y) = y := by
  -- 写像 `g : Y → X` を構成する
  choose g hg using hf

  -- `g` が満たす条件がローカルコンテキストに追加される
  guard_hyp g: Y → X
  guard_hyp hg: ∀ (y : Y), f (g y) = y

  exact ⟨g, hg⟩
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructor"><a class="header" href="#constructor">constructor</a></h1>
<p>ゴールが <code>⊢ P ∧ Q</code> であるとき，<code>constructor</code> を実行すると，ゴールが２つのゴール <code>⊢ P</code> と <code>⊢ Q</code> に分割されます．</p>
<pre><code class="language-lean">example (hP: P) (hQ: Q) : P ∧ Q := by
  -- goal が `left` と `right` に分割される
  constructor
  · -- `P` を示す
    exact hP
  · -- `Q` を示す
    exact hQ
</code></pre>
<p>なお <code>h: P ∧ Q</code> から <code>P</code> や <code>Q</code> の証明を得るのは，それぞれ <code>h.left</code> と <code>h.right</code> で可能です．</p>
<pre><code class="language-lean">example (h: P ∧ Q) : P := by
  exact h.left
</code></pre>
<h2 id="同値を示す"><a class="header" href="#同値を示す">同値を示す</a></h2>
<p><code>constructor</code> はゴールが <code>⊢ P ↔ Q</code> であるときにも使用できます．</p>
<pre><code class="language-lean">example (x : Nat) : x = 0 ↔ x + 1 = 1 := by
  constructor
  · -- `x = 0 → x + 1 = 1` を示す
    intro hx
    rw [hx]
  · -- `x + 1 = 1 → x = 0` を示す
    simp_all
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contradiction"><a class="header" href="#contradiction">contradiction</a></h1>
<p><code>contradiction</code> は，矛盾によりゴールを閉じるタクティクです．矛盾から任意の命題を証明することができます．</p>
<p>ローカルコンテキストに <code>P</code> と <code>¬ P</code> が同時にあるなど，矛盾した状況にあるときにゴールを閉じます．</p>
<pre><code class="language-lean">-- `False`
example (h : False) : P := by contradiction

-- 明らかに偽な等式
example (h : 2 + 2 = 3) : P := by contradiction

-- 明らかに偽な等式
example (x : Nat) (h : x ≠ x) : P := by contradiction

-- 矛盾する仮定
example (hP : P) (hnP : ¬ P) : Q := by contradiction
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conv"><a class="header" href="#conv">conv</a></h1>
<p><code>conv</code> は変換モードに入るためのタクティクです．詳細については<a href="https://aconite-ac.github.io/theorem_proving_in_lean4_ja/conv.html">Theorem Proving in Lean4</a>をご参照ください．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convert"><a class="header" href="#convert">convert</a></h1>
<p>needs: <code>import Mathlib.Tactic.Convert</code></p>
<p>ローカルコンテキストに現在のゴールに近いけれども等しくはない <code>h</code> があるとき，<code>exact h</code> としても失敗します．しかし <code>convert h</code> は成功する可能性があり，成功した場合は <code>h</code> とゴールの差分を新たなゴールとします．</p>
<pre><code class="language-lean">example (f : Nat → Nat) (h : f (a + b) = 0) (hc: a + b = c) : f (c) = 0 := by
  -- `h` はゴールと等しくないので失敗する
  try exact [h]

  -- `h` とゴールの差分を新たなゴールにする
  convert h

  -- ゴールが `⊢ c = a + b` に変わっている
  show c = a + b

  rw [hc]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="done"><a class="header" href="#done">done</a></h1>
<p><code>done</code> は，証明終了の合図です．証明すべきゴールが残っていない時に成功し，それ以外の時にはエラーになります．QED のようなものです．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exact-2"><a class="header" href="#exact-2">exact</a></h1>
<p>ゴールが <code>P</code> で，ローカルコンテキストに <code>hP: P</code> があるときに，<code>exact hP</code> はゴールを閉じます．</p>
<pre><code class="language-lean">example (hP: P) : P := by
  exact hP
</code></pre>
<p><code>hP</code> がゴールの証明になっていないときには，失敗してエラーになります．</p>
<p><code>exact ⟨ hP, hQ ⟩</code> のようにすると，論理積∧の形をした命題を証明することができます．</p>
<pre><code class="language-lean">example (hP: P) (hQ: Q) : P ∧ Q := by
  exact ⟨ hP, hQ ⟩
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exists"><a class="header" href="#exists">exists</a></h1>
<p><code>exists</code> は，「～という <code>x</code> が存在する」という命題を示すために，「この <code>x</code> を使え」と指示するコマンドです．</p>
<p>ゴールが <code>⊢ ∃ x, P x</code> のとき，<code>x: X</code> がローカルコンテキストにあれば，<code>exists x</code> によりゴールが <code>P x</code> に変わります．同時に，<code>P x</code> が自明な場合は証明が終了します．</p>
<pre><code class="language-lean">example : ∃ x : Nat, 3 * x + 1 = 7 := by
  exists 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ext"><a class="header" href="#ext">ext</a></h1>
<p>needs: <code>import Std.Tactic.Ext</code></p>
<p>named after: 外延性(extensionality)</p>
<p><code>ext</code> は，外延性を使うタクティクです．外延性とは，「同じものから作られているものは同じである」という主張のことです．たとえば</p>
<ul>
<li>集合 <code>A, B ⊂ α</code> について <code>A = B</code> は <code>x ∈ A ↔ x ∈ B</code> と同じ</li>
<li>2つの写像 <code>f g : A → B</code> があるとき <code>f = g</code> は <code>∀ a ∈ A, f a = g a</code> と同じ</li>
</ul>
<p>といったことを指します．</p>
<p><code>@[ext]</code> で登録されたルールを使用するため，集合の等式 <code>A = B</code> を示すときは <code>Mathlib.Data.SetLike.Basic</code> も必要です．</p>
<pre><code class="language-lean">variable {α : Type}

-- `s` と `t` は `α` の部分集合
variable (s t : Set α)

example : s ∩ t = t ∩ s := by
  -- `x ∈ α` を取る．` x ∈ s ∩ t ↔ x ∈ t ∩ s` を証明すればよい
  ext x

  aesop
</code></pre>
<p>なお <code>A ⊂ B</code> を示すために元を取るのは <code>intro x</code> で可能です．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funext"><a class="header" href="#funext">funext</a></h1>
<p>関数 <code>f</code> と <code>g</code> が等しいことを示す際に，引数 <code>x</code> をとって <code>f x = g x</code> を示そうとすることがありますが，<code>funext</code> はそれを行うタクティクです.</p>
<pre><code class="language-lean">def f := fun (x : Nat) ↦ x + x

def g := fun (x : Nat) ↦ 2 * x

example : f = g := by
  -- 引数 `x` を取る
  funext x

  -- `f x` と `g x` を展開する
  dsimp [f, g]

  -- `x + x` と `2 * x` が等しいことを証明する
  ring
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="have"><a class="header" href="#have">have</a></h1>
<p><code>have</code> は，証明の途中でわかることをローカルコンテキストに追加するコマンドです．</p>
<p><code>have h: P := ...</code> で <code>P</code> という命題の証明を構成し，その証明に <code>h</code> という名前を付けることができます．</p>
<pre><code class="language-lean">example (hPQ: P → Q) (hQR: Q → R) : P → R := by
  -- 示したいことが `P → R` なので，`P` だと仮定する
  intro hP

  -- 仮定 `hPQ : P → Q` と `hP : P` から `Q` が導かれる
  have hQ : Q := by exact hPQ hP

  -- 仮定 `hQR : Q → R` と `hQ : Q` から `R` が導かれる
  exact hQR hQ
</code></pre>
<p>名前を省略して <code>have : P := ...</code> とすると，自動的に <code>this</code> という名前になります．</p>
<h2 id="パターンマッチ"><a class="header" href="#パターンマッチ">パターンマッチ</a></h2>
<p>補題を示すだけでなく，ある特定の形をした主張を分解するのにも <code>have</code> は使うことができます．</p>
<h3 id="論理積-"><a class="header" href="#論理積-">論理積 ∧</a></h3>
<p>次のように，<code>P ∧ Q</code> という命題から <code>P</code> と <code>Q</code> を取り出すことができます．</p>
<pre><code class="language-lean">example (hPQ: P ∧ Q) : P := by
  -- `P ∧ Q` という仮定を分解する
  -- `hQ: Q` は不要なのでアンダースコアに置き換える
  have ⟨ hP, _ ⟩ := hPQ

  assumption
</code></pre>
<h3 id="存在-"><a class="header" href="#存在-">存在 ∃</a></h3>
<p>次のように，<code>∃ x: X, P x</code> という命題から，条件を満たす <code>x</code> を取り出すことができます．<code>x: X</code> と <code>hx: P x</code> がローカルコンテキストに追加されます．</p>
<pre><code class="language-lean">-- `x`が偶数のとき`3 * x`も偶数
example (x : ℕ) (hx : ∃ y, x = 2 * y) : ∃ z, 3 * x = 2 * z := by
  -- `hx` で存在が主張されている `y` と，
  -- `x = 2 * y` という命題を得る
  have ⟨y, hy⟩ := hx
  exists 3 * y
  rw [hy]
  ring
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="induction"><a class="header" href="#induction">induction</a></h1>
<p><code>induction</code> は，帰納法のためのタクティクです．</p>
<p>自然数を例に説明します．Lean では自然数は次のように帰納的に定義されています.</p>
<pre><code class="language-lean">inductive Nat
  | zero : Nat
  | succ (n : Nat) : Nat
</code></pre>
<p><code>succ</code> は後者関数と呼ばれる関数で，<code>n + 1 := succ n</code> です．</p>
<p><code>n : Nat</code> についてゴール <code>P n ⊢ Q n</code> があったとします．このとき <code>induction n</code> を行うと，コンストラクタ <code>zero</code> と <code>succ</code> のそれぞれに対して，対応するゴールを生成します．つまり</p>
<ul>
<li><code>P 0 ⊢ Q 0</code></li>
<li><code>(P (succ a)) (P a → Q a) ⊢ Q (succ a)</code></li>
</ul>
<p>の２つのゴールです．</p>
<pre><code class="language-lean">-- 階乗関数
def fac : Nat → Nat
  | 0 =&gt; 1
  | n + 1 =&gt; (n + 1) * fac n

example (n : Nat) : 0 &lt; fac n := by
  -- `n` についての帰納法で示す
  induction n with
  | zero =&gt;
    -- `fac` の定義から従う
    simp [fac]
  | succ n ih =&gt;
    -- `fac` の定義から従う
    simp [fac]
    positivity
</code></pre>
<h2 id="induction-1"><a class="header" href="#induction-1">induction'</a></h2>
<p>needs: <code>import Mathlib.Tactic.Cases</code></p>
<p><code>induction'</code> というタクティクもあります．こちらは箇条書きによる，より簡潔な書き方が可能です．</p>
<pre><code class="language-lean">example (n : Nat) : 0 &lt; fac n := by
  -- `ih` は帰納法の仮定
  -- `k` は `ih` に登場する変数
  induction' n with k ih
  · simp [fac]
  · simp [fac]
    positivity
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intro"><a class="header" href="#intro">intro</a></h1>
<p>named after: 導入(introduce)</p>
<p><code>intro</code> は数学で慣習的に行われる</p>
<ul>
<li><code>P → Q</code> を示すときに最初に <code>P</code> を仮定する</li>
<li><code>∀ x ∈ A, P(x)</code> を示すときに最初に <code>x ∈ A</code> が与えられたと仮定する</li>
</ul>
<p>といった導入を実行します．</p>
<p>具体的には，<code>intro</code> は</p>
<ul>
<li>ゴールが <code>⊢ P → Q</code> という形であるときに <code>P</code> をローカルコンテキストに追加して，ゴールを <code>⊢ Q</code> に変える</li>
<li>ゴールが <code>⊢ ∀ x, P x</code> という形であるときに <code>x</code> をローカルコンテキストに追加してゴールを <code>⊢ P x</code> に変える</li>
</ul>
<p>といった挙動をします．</p>
<pre><code class="language-lean">example (hPQ: P → Q) (hQR: Q → R) : P → R := by
  -- 示したいことが `P → R` なので，`P` だと仮定する
  intro hP

  -- `R` を示したい
  show R

  -- 仮定 `hPQ : P → Q` と `hP : P` から `Q` が導かれる
  have hQ : Q := hPQ hP

  -- 仮定 `hQR : Q → R` と `hQ : Q` から `R` が導かれる
  exact hQR hQ
</code></pre>
<p>もう一つ使用例を挙げておきます：</p>
<pre><code class="language-lean">example (P Q : Nat → Prop) (h : ∀ n, P n ↔ Q n) : ∀ y, P (y + 1) → Q (y + 1) := by
  -- 任意の `y` について示すので，`intro` で `y` を導入する
  -- そして `P (y + 1) → Q(y + 1)` を示したいので，`P (y + 1)` を仮定する
  intro y hyP

  -- `Q (y + 1)` を示せば良い
  show Q (y + 1)

  -- 同値を使ってゴールを書き換える
  rw [← h]

  -- 仮定 `P (y + 1)` より従う
  assumption
</code></pre>
<h2 id="否定--について-1"><a class="header" href="#否定--について-1">否定 ¬ について</a></h2>
<p>Lean では否定 <code>¬ P</code> は <code>P → False</code> として定義されているので，ゴールが <code>¬ P</code> のときに <code>intro</code> すると <code>P</code> が仮定に追加されて，ゴールが <code>False</code> に変わります．</p>
<p><code>False</code> は矛盾を導けば証明できます．</p>
<pre><code class="language-lean">example (h: P → Q) : ¬Q → ¬P := by
  -- 示したいことが `¬Q → ¬P` なので，`¬Q` だと仮定する
  -- そうするとゴールが `¬P` になるので，
  -- さらに `intro` を行って仮定 `hP : P` を導入する
  intro hnQ hP

  -- 矛盾を示したい
  show False

  -- `hP : P` と `h : P → Q` から `Q` が導かれる
  have hQ : Q := h hP

  -- `hQ : Q` と `hnQ : ¬Q` から矛盾が導かれる
  contradiction
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="left-right"><a class="header" href="#left-right">left, right</a></h1>
<p>needs: <code>import Mathlib.Tactic.LeftRight</code></p>
<p>ゴールが <code>⊢ P ∨ Q</code> であるとき，<code>left</code> はゴールを <code>⊢ P</code> に，<code>right</code> はゴールを <code>⊢ Q</code> に変えます．</p>
<pre><code class="language-lean">example (hP: P) : P ∨ Q := by
  left
  assumption
</code></pre>
<p><code>left</code>, <code>right</code> を使わずに Mathlib4 なしで同じことをするには，<code>Or.inl</code> または <code>Or.inr</code> を使用します．</p>
<pre><code class="language-lean">example (hP: P) : P ∨ Q := by
  apply Or.inl
  assumption
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linarith"><a class="header" href="#linarith">linarith</a></h1>
<p>needs: <code>import Mathlib.Tactic.Linarith</code></p>
<p>named after: 線形算術(linear arithmetic)</p>
<p><code>linarith</code> は線形な不等式を導くことができます．</p>
<pre><code class="language-lean">example (h1 : 2 * x &lt; 3 * y) (h2 : -4 * x + 2 * z &lt; 0): 12 * y - 4 * z ≥ 0 := by
  linarith
</code></pre>
<p><code>linarith</code> はローカルコンテキストを読み取ってくれるので，<code>linarith</code> が通らないとき補題を追加してあげると通るようになることがあります．</p>
<pre><code class="language-lean">example : id x ≤ x := by
  -- `linarith` で示すことはできない
  try linarith

  have : id x = x := rfl

  -- `id x = x` だと教えてあげると `linarith` で示せる
  linarith
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rel"><a class="header" href="#rel">rel</a></h1>
<p>needs: <code>import Mathlib.Tactic.GCongr</code></p>
<p>named after: 関係(relation)</p>
<p><code>rel</code> は，不等式を代入して適用し，不等式を示します．</p>
<pre><code class="language-lean">example (h1 : a ≤ b) (h2 : c ≤ d) : a + c ≤ b + d := by
  rel [h1, h2]
</code></pre>
<p><code>rel</code> は，たとえば整数 <code>x: Int</code> に対して <code>0 ≤ x ^ 2</code> であることを自動的に適用するなど, 多少の推論を行います．</p>
<pre><code class="language-lean">example (x: Int) (h1 : a ≤ b) : x ^ 2 * a ≤ x ^ 2 * b := by
  rel [h1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfl"><a class="header" href="#rfl">rfl</a></h1>
<p>named after: 反射律(reflexivity)</p>
<p><code>rfl</code> は，定義から等しいものが等しいことを示すタクティクです．</p>
<pre><code class="language-lean">-- 自明に正しい等式
example : 1 + 1 = 2 := by rfl

-- 変数を含む等式
example (x : Nat) : x = x := by rfl

example (P : Prop) : P = P := by rfl
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ring"><a class="header" href="#ring">ring</a></h1>
<p>needs: <code>import Mathlib.Tactic.Ring</code></p>
<p><code>ring</code> は，可換環の等式を示します．</p>
<pre><code class="language-lean">example : (x + y) ^ 2 = x ^ 2 + 2 * x * y + y ^ 2 := by
  ring
</code></pre>
<p><code>simp</code> 等と異なり，<code>ring?</code> タクティクは用意されていませんが，<code>show_term</code> で具体的にどんなルールが適用されたのかを知ることができます．ただし，その出力結果は非常に長く読みづらいものであることがしばしばです．例えば，</p>
<pre><code class="language-lean">example : (x + y) ^ 2 = x ^ 2 + 2 * x * y + y ^ 2 := by
  show_term ring
</code></pre>
<p>の出力をここに掲載すると100行を超えてしまいます．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rw"><a class="header" href="#rw">rw</a></h1>
<p><code>rw</code> は rewrite（書き換え）を行うタクティクです．等式や同値をもとに書き換えを行います．</p>
<p><code>hab: a = b</code> や <code>hPQ : P ↔ Q</code> がローカルコンテキストにあるとき，</p>
<ul>
<li><code>rw [hab]</code> はゴールの中の <code>a</code> をすべて <code>b</code> に置き換え，</li>
<li><code>rw [hPQ]</code> はゴールの中の <code>P</code> をすべて <code>Q</code> に置き換えます．</li>
</ul>
<p>順番は重要で，<code>b</code> を <code>a</code> に置き換えたいときなどは <code>rw [← hab]</code> のように <code>←</code> をつけます．</p>
<p><code>h1, h2, ...</code> について続けて置き換えを行いたいときは，<code>rw [h1, h2, ...]</code> のようにします．</p>
<p>ゴールではなく，ローカルコンテキストにある <code>h: P</code> を書き換えたいときには <code>at</code> をつけて <code>rw [hPQ] at h</code> とします．すべての箇所で置き換えたいときは <code>rw [hPQ] at *</code> とします．</p>
<pre><code class="language-lean">example (a b c d e f : Nat) (h : a * b = c * d) (h' : e = f) : a * (b * e) = c * (d * f) := by
  rw [h']

  -- 結合法則を使う
  rw [← Nat.mul_assoc]
  rw [h]

  -- 結合法則を使う
  rw [Nat.mul_assoc]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="show"><a class="header" href="#show">show</a></h1>
<p><code>show P</code> は, ゴールの中に <code>⊢ P</code> があるときにそれをメインのゴールにします．</p>
<p>たとえば，証明中にこれから示すべきことを明示し，コードを読みやすくする目的で使うことができます．</p>
<pre><code class="language-lean">example (hP: P) (hQ: Q) : P ∧ Q := by
  constructor
  · show P
    exact hP
  · show Q
    exact hQ
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simp"><a class="header" href="#simp">simp</a></h1>
<p><code>simp</code> は，ターゲットを決められた規則に基づいて自動で簡約（simplify）するタクティクです．カスタマイズすることが可能で，簡約に使ってほしい命題を登録することができます．</p>
<pre><code class="language-lean">universe u v

-- 圏の公理
class Category (C : Type u) where
  -- 射
  Hom : C → C → Type v

  -- 射の合成
  comp : ∀ {a b c : C}, Hom a b → Hom b c → Hom a c

  -- 恒等射. `id a` が `a` 上の恒等射を意味する
  id : ∀ (a : C), Hom a a

  -- 恒等射の性質
  id_comp : ∀ {a b : C} (f : Hom a b), comp (id a) f = f
  comp_id : ∀ {a b : C} (f : Hom a b), comp f (id b) = f

  -- 射の結合律
  assoc : ∀ {a b c d : C} (f : Hom a b) (g : Hom b c) (h : Hom c d),
    comp (comp f g) h = comp f (comp g h)

-- `f : Hom a b`と`g : Hom b c`の合成を`f ≫ g`と書く
infixr:80 &quot; ≫ &quot; =&gt; Category.comp

-- `Category.hoge` ではなく `hoge` で呼び出せるようにする
open Category

-- 公理の等式が `simp` で使えるようにする
attribute [simp] id_comp comp_id assoc

-- 変数の定義
variable {C : Type u} [Category.{u, v} C] {a b c d e : C}

example (f : Hom a b) (g : Hom b c) (h : Hom c d) (i : Hom d e) :
    (f ≫ (id b ≫ g)) ≫ (h ≫ i) = f ≫ (g ≫ ((id c ≫ h) ≫ i)) := by
  -- 上で `simp` で使えるようにした等式を使って自動で簡約する
  simp
</code></pre>
<p>既知の <code>h: P</code> という証明を使って簡約させたいときは，明示的に <code>simp [h]</code> と指定することで可能です．</p>
<p>何も指定しなければゴールを簡約しますが，ローカルコンテキストにある <code>h: P</code> を簡約させたければ <code>simp at h</code> と指定することで可能です．</p>
<h2 id="simp-1"><a class="header" href="#simp-1">simp?</a></h2>
<p><code>simp</code> は自動的に証明を行ってくれますが，何が使われたのか知りたいときもあります．<code>simp?</code> は簡約に何が使われたのかを示してくれるので，<code>rw</code> などを用いて明示的に書き直すことができます．</p>
<h2 id="simp_all"><a class="header" href="#simp_all">simp_all</a></h2>
<p><code>simp_all</code> は <code>simp [*] at *</code> の強化版で，ローカルコンテキストとゴールをこれ以上簡約できなくなるまですべて簡約します．</p>
<h2 id="dsimp"><a class="header" href="#dsimp">dsimp</a></h2>
<p><code>dsimp</code> は，定義上(definitionally)等しいもの同士しか簡約しないという制約付きの <code>simp</code> です．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sorry"><a class="header" href="#sorry">sorry</a></h1>
<p>証明の細部を埋める前にコンパイルが通るようにしたいとき，証明で埋めるべき箇所に <code>sorry</code> と書くとコンパイルが通るようになります．ただし，<code>sorry</code> を使用しているという旨の警告が出ます．</p>
<pre><code class="language-lean">-- Fermat の最終定理
def FermatLastTheorem :=
  ∀ x y z n : Nat, n &gt; 2 ∧ x * y * z ≠ 0 → x ^ n + y ^ n ≠ z ^ n

theorem flt : FermatLastTheorem :=
  sorry
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="suffices"><a class="header" href="#suffices">suffices</a></h1>
<p><code>suffices</code> は，数学でよくある「～を示せば十分である」という推論を行うタクティクです．</p>
<p>ゴールが <code>⊢ P</code> であるときに <code>suffices Q from</code> を実行すると，</p>
<ul>
<li><code>suffices Q from</code> のブロック内では，仮定に <code>this: Q</code> が追加され，</li>
<li><code>suffices Q from</code> 以降では，ゴールが <code>⊢ Q</code> に書き換えられます．</li>
</ul>
<p><code>apply</code> と似ていますが，<code>apply</code> と違って「十分条件になっていること」の証明が明らかでないときにも使うことができます．</p>
<pre><code class="language-lean">example (hPQ: P → Q) (hQR: Q → R) (hP: P) : R := by
  -- `Q` を示せば十分
  suffices Q from hQR this

  exact hPQ hP
</code></pre>
<p><code>suffices Q from ...</code> という形式の場合は，証明を直接構成することが必要です．<code>suffices Q from by ...</code> とすると，タクティクによって証明を構成するモードになります．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trivial"><a class="header" href="#trivial">trivial</a></h1>
<p><code>trivial</code> は明らかなことを示します．</p>
<p><code>trivial</code> は，<code>rfl</code> や <code>contradiction</code> などのタクティクを実行して，現在のゴールを閉じようとします．</p>
<pre><code class="language-lean">-- 定義から明らかな等式
example : 1 + 1 = 2 := by trivial

-- 矛盾があるので, どんな命題でも証明できる
example (h: False) : P := by trivial
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="highlight.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
