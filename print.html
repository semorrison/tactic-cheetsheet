<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lean4 タクティク逆引きリスト</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Lean4 タクティク逆引きリスト</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="aesop.html">aesop: ルーチン自動化</a></li><li class="chapter-item expanded "><a href="apply.html">apply: 含意→を使う</a></li><li class="chapter-item expanded "><a href="apply_question.html">apply?: ライブラリ検索</a></li><li class="chapter-item expanded "><a href="assumption.html">assumption: 仮定をそのまま使う</a></li><li class="chapter-item expanded "><a href="by_cases.html">by_cases: 排中律</a></li><li class="chapter-item expanded "><a href="by_contra.html">by_contra: 背理法</a></li><li class="chapter-item expanded "><a href="by.html">by: タクティクモードに入る</a></li><li class="chapter-item expanded "><a href="calc.html">calc: 計算モードに入る</a></li><li class="chapter-item expanded "><a href="cases.html">cases: 論理和∨を使う</a></li><li class="chapter-item expanded "><a href="choose.html">choose: ∀x∃yP(x,y)から写像を作る</a></li><li class="chapter-item expanded "><a href="constructor.html">constructor: 論理積∧を示す</a></li><li class="chapter-item expanded "><a href="contradiction.html">contradiction: 矛盾</a></li><li class="chapter-item expanded "><a href="conv.html">conv: 変換モードに入る</a></li><li class="chapter-item expanded "><a href="convert.html">convert: 惜しい補題を使う</a></li><li class="chapter-item expanded "><a href="done.html">done: 証明終了を宣言</a></li><li class="chapter-item expanded "><a href="exact.html">exact: 証明を直接構成</a></li><li class="chapter-item expanded "><a href="exact_question.html">exact?: ライブラリ検索</a></li><li class="chapter-item expanded "><a href="exists.html">exists: 存在∃を示す</a></li><li class="chapter-item expanded "><a href="ext.html">ext: 外延性を使う</a></li><li class="chapter-item expanded "><a href="funext.html">funext: 関数等式を示す</a></li><li class="chapter-item expanded "><a href="guard_hyp.html">guard_hyp: 仮定や補題を確認</a></li><li class="chapter-item expanded "><a href="have.html">have: 補題を用意する</a></li><li class="chapter-item expanded "><a href="induction.html">induction: 帰納法</a></li><li class="chapter-item expanded "><a href="intro.html">intro: 含意→や全称∀を示す</a></li><li class="chapter-item expanded "><a href="left_right.html">left, right: 論理和∨を示す</a></li><li class="chapter-item expanded "><a href="linarith.html">linarith: 線形(不)等式を示す</a></li><li class="chapter-item expanded "><a href="nlinarith.html">nlinarith: 非線形な(不)等式を示す</a></li><li class="chapter-item expanded "><a href="push_neg.html">push_neg: ドモルガン</a></li><li class="chapter-item expanded "><a href="refine.html">refine: プレースホルダを使う</a></li><li class="chapter-item expanded "><a href="rel.html">rel: 不等式を使う</a></li><li class="chapter-item expanded "><a href="replace.html">replace: 補題の入れ替え</a></li><li class="chapter-item expanded "><a href="rfl.html">rfl: 関係の反射性を示す</a></li><li class="chapter-item expanded "><a href="ring.html">ring: 環の等式を示す</a></li><li class="chapter-item expanded "><a href="rw.html">rw: 同値変形</a></li><li class="chapter-item expanded "><a href="says.html">says: タクティク提案の痕跡を残す</a></li><li class="chapter-item expanded "><a href="show.html">show: 示すべきことを宣言</a></li><li class="chapter-item expanded "><a href="simp.html">simp: 簡約</a></li><li class="chapter-item expanded "><a href="sorry.html">sorry: 証明したことにする</a></li><li class="chapter-item expanded "><a href="suffices.html">suffices: 十分条件に帰着</a></li><li class="chapter-item expanded "><a href="trivial.html">trivial: 自明</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean4 タクティク逆引きリスト</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/lean-ja/tactic-cheetsheet" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lean4-タクティク逆引きリスト"><a class="header" href="#lean4-タクティク逆引きリスト">Lean4 タクティク逆引きリスト</a></h1>
<p>「普段の数学を Lean でどうやって実現するんだろう」という疑問に答えるために，よく使うタクティクをユースケースから逆引きできるようにまとめたリストです．</p>
<p>なお，タクティクの説明に付記している名前の由来についての説明は公式に説明があったものではなく，あくまで憶測であることをお断りしておきます．</p>
<h2 id="リンク集"><a class="header" href="#リンク集">リンク集</a></h2>
<ul>
<li>
<p><a href="https://lean-ja.github.io/math-in-type-theory-ja/">Mathematics in type Theory 日本語訳</a> このリストでは「命題は型，証明はその項」という型理論を基礎として数学を実装する際の事実は既知としています．こういった話に全く馴染みがない方は，まずこちらの記事を読まれると良いと思います．</p>
</li>
<li>
<p><a href="https://github.com/haruhisa-enomoto/mathlib4-all-tactics/blob/main/all-tactics.md">mathlib4-all-tactics</a> 全タクティクの網羅的なリスト．</p>
</li>
<li>
<p><a href="https://github.com/yuma-mizuno/lean-math-workshop">数学系のためのLean勉強会</a> Lean で数学をどのように実装するのか，実際に実装する過程を追うことで学べる教材です．いくつかコード例を拝借させていただきました．</p>
</li>
<li>
<p><a href="https://www.ma.imperial.ac.uk/~buzzard/xena/formalising-mathematics-2023/Part_C/Part_C.html">Formalizing Mathematics</a> Lean3 による例ですが，よく使うタクティクを平易な解説とともに紹介しているリストです．コード例や解説を参考にさせていただきました．</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aesop"><a class="header" href="#aesop">aesop</a></h1>
<p>needs: <code>import Aesop</code></p>
<p><code>aesop</code> は，<code>intro</code> や <code>simp</code> を使用してルーチンな証明を自動で行おうとします．</p>
<pre><code class="language-lean">-- 合成 `g ∘ f` が単射なら，`f` も単射
example {f : X → Y} {g : Y → Z} (hgfinj : Injective (g ∘ f)) : Injective f := by
  rw [Injective]
  aesop
</code></pre>
<h2 id="aesop-1"><a class="header" href="#aesop-1">aesop?</a></h2>
<p><code>aesop</code> が成功したとき，<code>aesop?</code> に置き換えると，ゴールを達成するのにどんなタクティクを使用したか教えてくれます．</p>
<pre><code class="language-lean">example {f : X → Y} {g : Y → Z} (hgfinj : Injective (g ∘ f)) : Injective f := by
  rw [Injective]
  -- `aesop?` は以下を返す
  intro a₁ a₂ a
  apply hgfinj
  simp_all only [comp_apply]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apply"><a class="header" href="#apply">apply</a></h1>
<p><code>apply</code> は含意 <code>→</code> をゴールに適用するタクティクです．</p>
<p>ゴールが <code>⊢ Q</code> で，ローカルコンテキストに <code>h: P → Q</code> があるときに，<code>apply h</code> を実行するとゴールが <code>⊢ P</code> に書き換わります．</p>
<pre><code class="language-lean">-- `P → Q` かつ `P` ならば `Q`
example (h: P → Q) (hP: P) : Q := by
  apply h

  -- ゴールが `P` に変わっている
  show P

  exact hP
</code></pre>
<p>注意点として，<code>h: P → Q</code> は <code>P</code> の証明を受け取って <code>Q</code> の証明を返す関数でもあるので，上記の例は <code>apply</code> を使わずに <code>exact h hP</code> で閉じることもできます．</p>
<pre><code class="language-lean">-- `P → Q` かつ `P` ならば `Q`
example (h: P → Q) (hP: P) : Q := by
  exact h hP
</code></pre>
<h2 id="否定--について"><a class="header" href="#否定--について">否定 ¬ について</a></h2>
<p>また，Lean では否定 <code>¬ P</code> は <code>P → False</code> として実装されているため，ゴールが <code>⊢ False</code> であるときに <code>hn: ¬P</code> に対して <code>apply hn</code> とするとゴールが <code>⊢ P</code> に書き換わります．</p>
<pre><code class="language-lean">-- 矛盾
example (hn: ¬ P) (hP: P) : False := by
  -- ゴールが `P` に変わる
  apply hn

  exact hP
</code></pre>
<h2 id="よくあるエラー"><a class="header" href="#よくあるエラー">よくあるエラー</a></h2>
<p><code>apply</code> には引数が必須なのですが，省略しても近くにエラーが出ません．一般に，構文的に間違った証明を書いた場合には，エラーがわかりやすい場所に出てくれる保証はありません．</p>
<h2 id="exact-との関連"><a class="header" href="#exact-との関連">exact との関連</a></h2>
<p><a href="./exact.html">exact</a> の代わりに <code>apply</code> を使うことができます．</p>
<pre><code class="language-lean">-- `P → Q` かつ `P` ならば `Q`
example (h: P → Q) (hP: P) : Q := by
  apply h
  apply hP
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apply-1"><a class="header" href="#apply-1">apply?</a></h1>
<p>needs: <code>import Mathlib.Tactic.LibrarySearch</code></p>
<p><code>apply?</code> は，ゴールを閉じるのに必要な命題をライブラリから検索してきて，提案してくれるタクティクです．</p>
<pre><code class="language-lean">-- 群準同型は積を保つ
example [Group G] [Group H] (f : G →* H) (a b : G) :
    f (a * b) = f a * f b := by
    -- `exact MonoidHom.map_mul f a b` を提案してくれる
    apply?
</code></pre>
<p>複数の候補が提案されたときは，どれを選ぶとゴールが何に変わるのか表示されるので，その中から好ましいものを選ぶと良いでしょう．</p>
<h2 id="補足"><a class="header" href="#補足">補足</a></h2>
<p><code>apply?</code> はあくまで証明を書くときに補助として使うものです．<code>sorry</code> と同じように，清書した証明に残してはいけません．</p>
<p><code>sorry</code> と同じと言いましたが，実際 <code>apply?</code> は sorryAx <sup class="footnote-reference"><a href="#sorry">1</a></sup> を裏で使用します．これは，<code>#explode</code> で証明の中身を出力させれば分かります．<code>sorry</code> を使っているという旨の警告も出ます．</p>
<pre><code class="language-lean">theorem T (x y : Nat) (_: x ≤ y) : 2 ^ x ≤ 2 ^ y := by
    apply?

    -- `apply?` しただけで `done` が通り，示せているように見える
    done

/-
T : ∀ (x y : ℕ), x ≤ y → 2 ^ x ≤ 2 ^ y

0│       │ x       ├ ℕ
1│       │ y       ├ ℕ
2│       │ h       ├ x ≤ y
3│       │ sorryAx │ 2 ^ x ≤ 2 ^ y
4│0,1,2,3│ ∀I      │ ∀ (x y : ℕ), x ≤ y → 2 ^ x ≤ 2 ^ y
-/
#explode T
</code></pre>
<p><sup class="footnote-reference"><a href="#sorry">1</a></sup> <code>sorry</code> が裏で使用している公理のこと</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assumption"><a class="header" href="#assumption">assumption</a></h1>
<p><code>assumption</code> は，現在のゴール <code>⊢ P</code> がローカルコンテキストにあるとき，ゴールを閉じます．</p>
<pre><code class="language-lean">example (hP: P) (_: Q) : P := by
  assumption
</code></pre>
<h2 id="exact-との関連-1"><a class="header" href="#exact-との関連-1">exact との関連</a></h2>
<p><code>assumption</code> による証明は，どの仮定を使うか明示すれば <a href="./exact.html">exact</a> で書き直すことができます．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="by_cases"><a class="header" href="#by_cases">by_cases</a></h1>
<p><code>by_cases</code> は排中律を使って場合分けをするタクティクです．</p>
<p><code>by_cases h: P</code> とすると，<code>P</code> が成り立つときと成り立たないときのゴールがそれぞれ生成されます．</p>
<pre><code class="language-lean">example (P: Prop) : ¬¬P → P := by
  intro hnnP

  -- `P` が成り立つかどうかで場合分けする
  by_cases hP: P

  case inl =&gt;
    -- `P` が成り立つとき
    guard_hyp hP : P

    assumption

  case inr =&gt;
    -- `¬ P` が成り立つとき
    guard_hyp hP : ¬P

    contradiction
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="by_contra"><a class="header" href="#by_contra">by_contra</a></h1>
<p>needs: <code>import Mathlib.Tactic.ByContra</code></p>
<p><code>by_contra</code> は，背理法を使いたいときに役立つタクティクです．</p>
<p>ゴールが <code>⊢ P</code> であるときに <code>by_contra h</code> を実行すると，<code>h : ¬ P</code> がローカルコンテキストに追加されて，同時にゴールが <code>⊢ False</code> になります．</p>
<pre><code class="language-lean">example (h: ¬Q → ¬P) : P → Q := by
  -- `P` であると仮定する
  intro hP

  -- `¬Q` であると仮定して矛盾を導きたい
  by_contra hnQ
  show False

  -- `¬ Q → ¬ P` と `¬Q` から `¬P` が導かれる
  have := h hnQ

  -- これは仮定に矛盾
  contradiction
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="by"><a class="header" href="#by">by</a></h1>
<p>型理論においては，命題 <code>P</code> は型で，証明 <code>h : P</code> はその項です．証明を構成するとは項 <code>h</code> を構成するということです．<code>by</code> は，証明の構成をタクティクで行いたいときに使います．</p>
<pre><code class="language-lean">-- `P → R` というのは `P` の証明を与えられたときに `R` の証明を返す関数の型
-- したがって，その証明は関数となる
example (hPQ : P → Q) (hQR : Q → R) : P → R :=
  fun hP ↦ hQR (hPQ hP)


-- 同じ命題をタクティクで示した例
example (hPQ : P → Q) (hQR : Q → R) : P → R := by
  intro hP
  exact hQR (hPQ hP)
</code></pre>
<h2 id="by-1"><a class="header" href="#by-1">by?</a></h2>
<p>needs: <code>import Std.Tactic.ShowTerm</code></p>
<p><code>by?</code> を使うとタクティクモードで構成した証明を直接構成した証明に変換してくれます．</p>
<pre><code class="language-lean">example (hPQ : P → Q) (hQR : Q → R) : P → R := by?
  -- `Try this: fun hP =&gt; hQR (hPQ hP)` と提案してくれる
  intro hP
  exact hQR (hPQ hP)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calc"><a class="header" href="#calc">calc</a></h1>
<p><code>calc</code> は計算モードに入るためのタクティクです．詳細については<a href="https://aconite-ac.github.io/theorem_proving_in_lean4_ja/quantifiers_and_equality.html#calculational-proofs-%E8%A8%88%E7%AE%97%E7%9A%84%E8%A8%BC%E6%98%8E">Theorem Proving in Lean4</a>をご参照ください．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cases"><a class="header" href="#cases">cases</a></h1>
<p><code>cases</code> は場合分けを行います．ローカルコンテキストに <code>h: P ∨ Q</code> があるときに <code>cases h</code> とすると，仮定に <code>P</code> を付け加えたゴール <code>inl</code> と，仮定に <code>Q</code> を付け加えたゴール <code>inr</code> を生成します．それぞれ，<code>insert left</code> と <code>insert right</code> の略ではないかと思います．</p>
<pre><code class="language-lean">example : P ∨ Q → (P → R) → (Q → R) → R := by
  -- `h: P ∨ Q`
  intro h hPR hQR

  -- `case inl` と `case inr` の２つのゴールを生成する
  cases h

  -- `P` が成り立つ場合
  case inl hP =&gt;
    exact hPR hP

  -- `Q` が成り立つ場合
  case inr hQ =&gt;
    exact hQR hQ
</code></pre>
<h2 id="case-を書かない"><a class="header" href="#case-を書かない">case を書かない</a></h2>
<p>上記の例では <code>case</code> を場合分けの枝ごとに書いていますが，下の例のように <code>case</code> を書かずに済ませることもできます．</p>
<pre><code class="language-lean">example : P ∨ Q → (P → R) → (Q → R) → R := by
  -- `h: P ∨ Q`
  intro h hPR hQR

  -- `case inl` と `case inr` の２つのゴールを生成する
  cases h with
  | inl hP =&gt;
    exact hPR hP
  | inr hQ =&gt;
    exact hQR hQ
</code></pre>
<h2 id="cases-1"><a class="header" href="#cases-1">cases'</a></h2>
<p>needs: <code>import Mathlib.Tactic.Cases</code></p>
<p><code>cases'</code> を使用すると分解した仮定に簡潔に名前をつけることができます．</p>
<pre><code class="language-lean">example : P ∨ Q → (P → R) → (Q → R) → R := by
  intro h hPR hQR

  -- 場合分けをする
  cases' h with hP hQ
  · apply hPR hP
  · apply hQR hQ
</code></pre>
<h2 id="rcases"><a class="header" href="#rcases">rcases</a></h2>
<p>needs: <code>import Std.Tactic.RCases</code></p>
<p>named after: 再帰的(recursive) cases</p>
<p><code>rcases</code> は <code>cases</code> をパターンに従って再帰的に適用します．論理和∨以外にも使うことができます．</p>
<pre><code class="language-lean">variable (P Q R : Prop)

example : P ∨ Q → (P → R) → (Q → R) → R := by
  intro h hPR hQR

  -- 場合分けをする
  rcases h with hP | hQ
  · apply hPR hP
  · apply hQR hQ

example : P ∧ Q → Q ∧ P := by
  -- `h: P ∧ Q` と仮定する
  intro h

  -- `h: P ∧ Q` を `hP: P` と `hQ: Q` に分解する
  rcases h with ⟨hP, hQ⟩

  -- `Q ∧ P` を証明する
  exact ⟨hQ, hP⟩
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="choose"><a class="header" href="#choose">choose</a></h1>
<p>needs: <code>import Mathlib.Tactic.Choose</code></p>
<p><code>h : ∀ x, ∃ y, P(x, y)</code> が成り立っているときに，<code>choose f hf using h</code> は写像 <code>f: X → Y</code> と <code>f</code> が満たす性質 <code>hf : ∀ x, P(x, f x)</code> のペアを作ります．</p>
<pre><code class="language-lean">example (f : X → Y) (hf : ∀ y, ∃ x, f x = y) : ∃ g : Y → X, ∀ y, f (g y) = y := by
  -- 写像 `g : Y → X` を構成する
  choose g hg using hf

  -- `g` が満たす条件がローカルコンテキストに追加される
  guard_hyp g: Y → X
  guard_hyp hg: ∀ (y : Y), f (g y) = y

  exact ⟨g, hg⟩
</code></pre>
<h2 id="補足-1"><a class="header" href="#補足-1">補足</a></h2>
<p><code>choose</code> が自動で示してくれることは選択原理 <code>Classical.choice</code> を使って手動で示すことができます．たとえば次のようになります．</p>
<pre><code class="language-lean">variable (P : X → Y → Prop)

noncomputable example (h : ∀ x, ∃ y, P x y) : ∃ f : X → Y, ∀ x, P x (f x) := by
  -- `f` を作る
  let f' : (x : X) → {y // P x y} := fun x ↦
    have hne_st : Nonempty {y // P x y} :=
      let ⟨y, py⟩ := h x; ⟨⟨y, py⟩⟩
    Classical.choice hne_st

  let f : X → Y := fun x ↦ (f' x).val

  -- 上記で作った関数が条件を満たすことを示す
  have h₁ : ∀ x, P x (f x) := by
    intro x
    exact (f' x).property

  exists f
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructor"><a class="header" href="#constructor">constructor</a></h1>
<p>ゴールが <code>⊢ P ∧ Q</code> であるとき，<code>constructor</code> を実行すると，ゴールが２つのゴール <code>⊢ P</code> と <code>⊢ Q</code> に分割されます．</p>
<pre><code class="language-lean">example (hP: P) (hQ: Q) : P ∧ Q := by
  -- goal が `left` と `right` に分割される
  constructor
  · -- `P` を示す
    exact hP
  · -- `Q` を示す
    exact hQ
</code></pre>
<p>なお <code>h: P ∧ Q</code> から <code>P</code> や <code>Q</code> の証明を得るのは，それぞれ <code>h.left</code> と <code>h.right</code> で可能です．</p>
<pre><code class="language-lean">example (h: P ∧ Q) : P := by
  exact h.left
</code></pre>
<h2 id="同値を示す"><a class="header" href="#同値を示す">同値を示す</a></h2>
<p><code>constructor</code> はゴールが <code>⊢ P ↔ Q</code> であるときにも使用できます．</p>
<pre><code class="language-lean">example (x : Nat) : x = 0 ↔ x + 1 = 1 := by
  constructor
  · -- `x = 0 → x + 1 = 1` を示す
    intro hx
    rw [hx]
  · -- `x + 1 = 1 → x = 0` を示す
    simp_all
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contradiction"><a class="header" href="#contradiction">contradiction</a></h1>
<p><code>contradiction</code> は，矛盾によりゴールを閉じるタクティクです．矛盾から任意の命題を証明することができます．</p>
<p>ローカルコンテキストに <code>P</code> と <code>¬ P</code> が同時にあるなど，矛盾した状況にあるときにゴールを閉じます．</p>
<pre><code class="language-lean">-- `False`
example (h : False) : P := by contradiction

-- 明らかに偽な等式
example (h : 2 + 2 = 3) : P := by contradiction

-- 明らかに偽な等式
example (x : Nat) (h : x ≠ x) : P := by contradiction

-- 矛盾する仮定
example (hP : P) (hnP : ¬ P) : Q := by contradiction
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conv"><a class="header" href="#conv">conv</a></h1>
<p><code>conv</code> は変換モードに入るためのタクティクです．詳細については<a href="https://aconite-ac.github.io/theorem_proving_in_lean4_ja/conv.html">Theorem Proving in Lean4</a>をご参照ください．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convert"><a class="header" href="#convert">convert</a></h1>
<p>needs: <code>import Mathlib.Tactic.Convert</code></p>
<p>ローカルコンテキストに現在のゴールに近いけれども等しくはない <code>h</code> があるとき，<code>exact h</code> としても失敗します．しかし <code>convert h</code> は成功する可能性があり，成功した場合は <code>h</code> とゴールの差分を新たなゴールとします．</p>
<pre><code class="language-lean">example (f : Nat → Nat) (h : f (a + b) = 0) (hc: a + b = c) : f (c) = 0 := by
  -- `h` はゴールと等しくないので失敗する
  try exact [h]

  -- `h` とゴールの差分を新たなゴールにする
  convert h

  -- ゴールが `⊢ c = a + b` に変わっている
  show c = a + b

  rw [hc]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="done"><a class="header" href="#done">done</a></h1>
<p><code>done</code> は，証明終了の合図です．証明すべきゴールが残っていない時に成功し，それ以外の時にはエラーになります．QED のようなものです．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exact"><a class="header" href="#exact">exact</a></h1>
<p>ゴールが <code>P</code> で，ローカルコンテキストに <code>hP: P</code> があるときに，<code>exact hP</code> はゴールを閉じます．</p>
<pre><code class="language-lean">example (hP: P) : P := by
  exact hP
</code></pre>
<p><code>hP</code> がゴールの証明になっていないときには，失敗してエラーになります．</p>
<p><code>exact ⟨ hP, hQ ⟩</code> のようにすると，論理積∧の形をした命題を証明することができます．</p>
<pre><code class="language-lean">example (hP: P) (hQ: Q) : P ∧ Q := by
  exact ⟨ hP, hQ ⟩
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exact-1"><a class="header" href="#exact-1">exact?</a></h1>
<p>needs: <code>import Mathlib.Tactic.LibrarySearch</code></p>
<p><code>exact?</code> は，ライブラリとローカルコンテキストにある命題を使って，ゴールを閉じることができないか探索します．</p>
<pre><code class="language-lean">-- `exact?` はライブラリ検索を行う
example : x &lt; x + 1 := by
  -- `Try this: exact Nat.lt.base x` と出力される
  exact?
</code></pre>
<p><a href="./apply_question.html">apply?</a> と似ていますが，<code>apply?</code> とは異なりゴールを変形するのではなくて <code>exact</code> で直接閉じようとします．</p>
<pre><code class="language-lean">-- ローカルコンテキストにある仮定を自動で使ってゴールを導いてくれる
example (hPQ : P → Q) (hQR : Q → R) (hQ : P) : R := by
  -- `Try this: exact hQR (hPQ hQ)` と出力される
  exact?

  -- 証明は `exact?` だけで終わっている
  done
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exists"><a class="header" href="#exists">exists</a></h1>
<p><code>exists</code> は，「～という <code>x</code> が存在する」という命題を示すために，「この <code>x</code> を使え」と指示するコマンドです．</p>
<p>ゴールが <code>⊢ ∃ x, P x</code> のとき，<code>x: X</code> がローカルコンテキストにあれば，<code>exists x</code> によりゴールが <code>P x</code> に変わります．同時に，<code>P x</code> が自明な場合は証明が終了します．</p>
<pre><code class="language-lean">example : ∃ x : Nat, 3 * x + 1 = 7 := by
  exists 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ext"><a class="header" href="#ext">ext</a></h1>
<p>needs: <code>import Std.Tactic.Ext</code></p>
<p>named after: 外延性(extensionality)</p>
<p><code>ext</code> は，外延性を使うタクティクです．外延性とは，「同じものから作られているものは同じである」という主張のことです．たとえば</p>
<ul>
<li>集合 <code>A, B ⊂ α</code> について <code>A = B</code> は <code>x ∈ A ↔ x ∈ B</code> と同じ</li>
<li>2つの写像 <code>f g : A → B</code> があるとき <code>f = g</code> は <code>∀ a ∈ A, f a = g a</code> と同じ</li>
</ul>
<p>といったことを指します．</p>
<p><code>@[ext]</code> で登録されたルールを使用するため，集合の等式 <code>A = B</code> を示すときは <code>Mathlib.Data.SetLike.Basic</code> も必要です．</p>
<pre><code class="language-lean">variable {α : Type}

-- `s` と `t` は `α` の部分集合
variable (s t : Set α)

example : s ∩ t = t ∩ s := by
  -- `x ∈ α` を取る．` x ∈ s ∩ t ↔ x ∈ t ∩ s` を証明すればよい
  ext x

  aesop
</code></pre>
<p>なお <code>A ⊂ B</code> を示すために元を取るのは <code>intro x</code> で可能です．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funext"><a class="header" href="#funext">funext</a></h1>
<p>関数 <code>f</code> と <code>g</code> が等しいことを示す際に，引数 <code>x</code> をとって <code>f x = g x</code> を示そうとすることがありますが，<code>funext</code> はそれを行うタクティクです.</p>
<pre><code class="language-lean">def f := fun (x : Nat) ↦ x + x

def g := fun (x : Nat) ↦ 2 * x

example : f = g := by
  -- 引数 `x` を取る
  funext x

  -- `f x` と `g x` を展開する
  dsimp [f, g]

  -- `x + x` と `2 * x` が等しいことを証明する
  ring
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guard_hyp"><a class="header" href="#guard_hyp">guard_hyp</a></h1>
<p>needs: <code>import Std.Tactic.GuardExpr</code></p>
<p><code>guard_hyp</code> は，ローカルコンテキストにある命題を確認するタクティクです．指定した仮定が存在すれば成功し，そうでなければ失敗します．</p>
<pre><code class="language-lean">example (hP : P) : P := by
  -- 現在ローカルコンテキストにある命題を確認できる
  guard_hyp hP : P

  exact hP
</code></pre>
<p>通常の証明で使うことはあまりないかもしれません．このタクティクリストでは，ローカルコンテキストの変化を説明するために使用することがあります．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="have"><a class="header" href="#have">have</a></h1>
<p><code>have</code> は，証明の途中でわかることをローカルコンテキストに追加するコマンドです．</p>
<p><code>have h: P := ...</code> で <code>P</code> という命題の証明を構成し，その証明に <code>h</code> という名前を付けることができます．</p>
<pre><code class="language-lean">example (hPQ: P → Q) (hQR: Q → R) : P → R := by
  -- 示したいことが `P → R` なので，`P` だと仮定する
  intro hP

  -- 仮定 `hPQ : P → Q` と `hP : P` から `Q` が導かれる
  have hQ : Q := by exact hPQ hP

  -- 仮定 `hQR : Q → R` と `hQ : Q` から `R` が導かれる
  exact hQR hQ
</code></pre>
<p>名前を省略して <code>have : P := ...</code> とすると，自動的に <code>this</code> という名前になります．</p>
<h2 id="パターンマッチ"><a class="header" href="#パターンマッチ">パターンマッチ</a></h2>
<p>補題を示すだけでなく，ある特定の形をした主張を分解するのにも <code>have</code> は使うことができます．</p>
<h3 id="論理積-"><a class="header" href="#論理積-">論理積 ∧</a></h3>
<p>次のように，<code>P ∧ Q</code> という命題から <code>P</code> と <code>Q</code> を取り出すことができます．</p>
<pre><code class="language-lean">example (hPQ: P ∧ Q) : P := by
  -- `P ∧ Q` という仮定を分解する
  -- `hQ: Q` は不要なのでアンダースコアに置き換える
  have ⟨ hP, _ ⟩ := hPQ

  assumption
</code></pre>
<h3 id="存在-"><a class="header" href="#存在-">存在 ∃</a></h3>
<p>次のように，<code>∃ x: X, P x</code> という命題から，条件を満たす <code>x</code> を取り出すことができます．<code>x: X</code> と <code>hx: P x</code> がローカルコンテキストに追加されます．</p>
<pre><code class="language-lean">-- `x`が偶数のとき`3 * x`も偶数
example (x : ℕ) (hx : ∃ y, x = 2 * y) : ∃ z, 3 * x = 2 * z := by
  -- `hx` で存在が主張されている `y` と，
  -- `x = 2 * y` という命題を得る
  have ⟨y, hy⟩ := hx
  exists 3 * y
  rw [hy]
  ring
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="induction"><a class="header" href="#induction">induction</a></h1>
<p><code>induction</code> は，帰納法のためのタクティクです．</p>
<p>自然数を例に説明します．Lean では自然数は次のように帰納的に定義されています.</p>
<pre><code class="language-lean">inductive Nat
  | zero : Nat
  | succ (n : Nat) : Nat
</code></pre>
<p><code>succ</code> は後者関数と呼ばれる関数で，<code>n + 1 := succ n</code> です．</p>
<p><code>n : Nat</code> についてゴール <code>P n ⊢ Q n</code> があったとします．このとき <code>induction n</code> を行うと，コンストラクタ <code>zero</code> と <code>succ</code> のそれぞれに対して，対応するゴールを生成します．つまり</p>
<ul>
<li><code>P 0 ⊢ Q 0</code></li>
<li><code>(P (succ a)) (P a → Q a) ⊢ Q (succ a)</code></li>
</ul>
<p>の２つのゴールです．</p>
<pre><code class="language-lean">-- 階乗関数
def fac : Nat → Nat
  | 0 =&gt; 1
  | n + 1 =&gt; (n + 1) * fac n

example (n : Nat) : 0 &lt; fac n := by
  -- `n` についての帰納法で示す
  induction n with
  | zero =&gt;
    -- `fac` の定義から従う
    simp [fac]
  | succ n ih =&gt;
    -- `fac` の定義から従う
    simp [fac]
    positivity
</code></pre>
<h2 id="induction-1"><a class="header" href="#induction-1">induction'</a></h2>
<p>needs: <code>import Mathlib.Tactic.Cases</code></p>
<p><code>induction'</code> というタクティクもあります．こちらは箇条書きによる，より簡潔な書き方が可能です．</p>
<pre><code class="language-lean">example (n : Nat) : 0 &lt; fac n := by
  -- `ih` は帰納法の仮定
  -- `k` は `ih` に登場する変数
  induction' n with k ih
  · simp [fac]
  · simp [fac]
    positivity
</code></pre>
<h2 id="強い帰納法"><a class="header" href="#強い帰納法">強い帰納法</a></h2>
<p>時には，より強い帰納法が必要なこともあります．強い帰納法とは，たとえば</p>
<ul>
<li><code>P(0)</code> を示す</li>
<li><code>(∀ k &lt; n, P (k)) → P (n)</code> を示す</li>
<li>したがって <code>∀ n, P (n)</code> である</li>
</ul>
<p>という形式で表されるような帰納法のことです．これは超限帰納法の特別な場合です．これを使用するには，<code>Nat.strong_induction_on</code> を使って次のようにします．</p>
<pre><code class="language-lean">variable (P : Nat → Prop)

example (n : Nat) : P n := by
  -- `n` についての強い帰納法で示す
  induction' n using Nat.strong_induction_on with n ih

  -- 仮定が追加される
  guard_hyp ih : ∀ (m : ℕ), m &lt; n → P m

  match n with
  | 0 =&gt; sorry
  | k + 1 =&gt; sorry
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intro"><a class="header" href="#intro">intro</a></h1>
<p>named after: 導入(introduce)</p>
<p><code>intro</code> は数学で慣習的に行われる</p>
<ul>
<li><code>P → Q</code> を示すときに最初に <code>P</code> を仮定する</li>
<li><code>∀ x ∈ A, P(x)</code> を示すときに最初に <code>x ∈ A</code> が与えられたと仮定する</li>
</ul>
<p>といった導入を実行します．</p>
<p>具体的には，<code>intro</code> は</p>
<ul>
<li>ゴールが <code>⊢ P → Q</code> という形であるときに <code>P</code> をローカルコンテキストに追加して，ゴールを <code>⊢ Q</code> に変える</li>
<li>ゴールが <code>⊢ ∀ x, P x</code> という形であるときに <code>x</code> をローカルコンテキストに追加してゴールを <code>⊢ P x</code> に変える</li>
</ul>
<p>といった挙動をします．</p>
<pre><code class="language-lean">example (hPQ: P → Q) (hQR: Q → R) : P → R := by
  -- 示したいことが `P → R` なので，`P` だと仮定する
  intro hP

  -- `R` を示したい
  show R

  -- 仮定 `hPQ : P → Q` と `hP : P` から `Q` が導かれる
  have hQ : Q := hPQ hP

  -- 仮定 `hQR : Q → R` と `hQ : Q` から `R` が導かれる
  exact hQR hQ
</code></pre>
<p>もう一つ使用例を挙げておきます：</p>
<pre><code class="language-lean">example (P Q : Nat → Prop) (h : ∀ n, P n ↔ Q n) : ∀ y, P (y + 1) → Q (y + 1) := by
  -- 任意の `y` について示すので，`intro` で `y` を導入する
  -- そして `P (y + 1) → Q(y + 1)` を示したいので，`P (y + 1)` を仮定する
  intro y hyP

  -- `Q (y + 1)` を示せば良い
  show Q (y + 1)

  -- 同値を使ってゴールを書き換える
  rw [← h]

  -- 仮定 `P (y + 1)` より従う
  assumption
</code></pre>
<h2 id="否定--について-1"><a class="header" href="#否定--について-1">否定 ¬ について</a></h2>
<p>Lean では否定 <code>¬ P</code> は <code>P → False</code> として定義されているので，ゴールが <code>¬ P</code> のときに <code>intro</code> すると <code>P</code> が仮定に追加されて，ゴールが <code>False</code> に変わります．</p>
<p><code>False</code> は矛盾を導けば証明できます．</p>
<pre><code class="language-lean">example (h: P → Q) : ¬Q → ¬P := by
  -- 示したいことが `¬Q → ¬P` なので，`¬Q` だと仮定する
  -- そうするとゴールが `¬P` になるので，
  -- さらに `intro` を行って仮定 `hP : P` を導入する
  intro hnQ hP

  -- 矛盾を示したい
  show False

  -- `hP : P` と `h : P → Q` から `Q` が導かれる
  have hQ : Q := h hP

  -- `hQ : Q` と `hnQ : ¬Q` から矛盾が導かれる
  contradiction
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="left-right"><a class="header" href="#left-right">left, right</a></h1>
<p>needs: <code>import Mathlib.Tactic.LeftRight</code></p>
<p>ゴールが <code>⊢ P ∨ Q</code> であるとき，<code>left</code> はゴールを <code>⊢ P</code> に，<code>right</code> はゴールを <code>⊢ Q</code> に変えます．</p>
<pre><code class="language-lean">example (hP: P) : P ∨ Q := by
  left
  assumption
</code></pre>
<p><code>left</code>, <code>right</code> を使わずに Mathlib4 なしで同じことをするには，<code>Or.inl</code> または <code>Or.inr</code> を使用します．</p>
<pre><code class="language-lean">example (hP: P) : P ∨ Q := by
  apply Or.inl
  assumption
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linarith"><a class="header" href="#linarith">linarith</a></h1>
<p>needs: <code>import Mathlib.Tactic.Linarith</code></p>
<p>named after: 線形算術(linear arithmetic)</p>
<p><code>linarith</code> は線形な(不)等式を導くことができます．</p>
<pre><code class="language-lean">example (h1 : 2 * x &lt; 3 * y) (h2 : -4 * x + 2 * z &lt; 0): 12 * y - 4 * z ≥ 0 := by
  linarith
</code></pre>
<p><code>linarith</code> はローカルコンテキストを読み取ってくれるので，<code>linarith</code> が通らないとき補題を追加してあげると通るようになることがあります．</p>
<pre><code class="language-lean">example : id x ≤ x := by
  -- `linarith` で示すことはできない
  try linarith

  have : id x = x := rfl

  -- `id x = x` だと教えてあげると `linarith` で示せる
  linarith
</code></pre>
<h2 id="補足-2"><a class="header" href="#補足-2">補足</a></h2>
<p>もう少し詳細に書くと，<code>linarith</code> は「ロールコンテキストにある線形な(不)等式系に矛盾があるか調べる」タクティクなので，次のような使い方もできます．</p>
<pre><code class="language-lean">example (h1: x = 2 * y) (h2 : - x + 2 * y = 1) : False := by
  linarith
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nlinarith"><a class="header" href="#nlinarith">nlinarith</a></h1>
<p>needs: <code>import Mathlib.Tactic.Linarith</code></p>
<p>named after: non-linear(非線形) arithmetic(算術)</p>
<p><code>nlinarith</code> は非線形な式も扱えるように <code>linarith</code> にいくつか前処理を追加したものです．</p>
<pre><code class="language-lean">example (a b: Nat) (h : a ≤ b) : a ^ 2 ≤ b ^ 2 := by
  -- `linarith` では示すことができない
  try linarith

  nlinarith
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="push_neg"><a class="header" href="#push_neg">push_neg</a></h1>
<p>needs: <code>import Mathlib.Tactic.PushNeg</code></p>
<p>named after: 押し込む(push) 否定(negation)</p>
<p><code>push_neg</code> はドモルガン則を使って，否定を式の中に押し込みます．たとえば</p>
<ul>
<li>
<p><code>¬ (P ∧ Q)</code> は <code>P → ¬ Q</code> に，</p>
</li>
<li>
<p><code>¬ ∀ x, P x</code> は <code>∃ x, ¬ P x</code> に</p>
</li>
</ul>
<p>という調子で変形します．<sup class="footnote-reference"><a href="#impl">1</a></sup></p>
<pre><code class="language-lean">example (h: P → Q) : ¬ (P ∧ ¬ Q) := by
  -- ドモルガン則を適用して，`¬` を内側に押し込む
  push_neg

  -- `¬` を内側に押し込んだ結果，`¬ P ∨ Q` が得られる
  -- これは `P → Q` と同値
  show P → Q

  exact h
</code></pre>
<pre><code class="language-lean">example : ¬ ∃ x : Int , ∀ y : Int, (x + y = 0) := by
  -- ドモルガン則を適用して，`¬` を内側に押し込む
  push_neg

  -- `¬` を内側に押し込んだ結果，ゴールが変わる
  show ∀ x, ∃ y, ¬ (x + y = 0)

  intro x
  exists (- x + 1)
  linarith
</code></pre>
<p><sup class="footnote-reference"><a href="#impl">1</a></sup> モードによって <code>¬ (P ∧ Q)</code> を <code>P → ¬ Q</code> としたり，<code>¬ P ∨ ¬ Q</code> としたりします．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refine"><a class="header" href="#refine">refine</a></h1>
<p><code>refine</code> は <code>exact</code> と同様に機能しますが，プレースホルダを受け入れて新しいゴールを生成するという違いがあります．</p>
<pre><code class="language-lean">example (hP: P) (hQ: Q) : P ∧ Q := by
  -- 穴埋め形式で証明を作ることができる
  refine ⟨?_, hQ⟩

  -- ゴールが `⊢ P` になる
  show P

  exact hP
</code></pre>
<h2 id="constructor-との関連"><a class="header" href="#constructor-との関連">constructor との関連</a></h2>
<p><code>refine</code> は <a href="./constructor.html">constructor</a> の代わりに使うこともできます．実際 <code>refine</code> は <code>constructor</code> よりも柔軟で，<code>⊢ P ∧ Q ∧ R</code> のような形のゴールは <code>constructor</code> よりも簡潔に分割できます．</p>
<pre><code class="language-lean">example (hP: P) (hQ: Q) (hR : R) : P ∧ Q ∧ R := by
  -- ゴールを３つに分割する
  refine ⟨?_, ?_, ?_⟩

  · show P
    exact hP
  · show Q
    exact hQ
  · show R
    exact hR

-- `constructor` を使った場合
-- 一度に２つのゴールに分割することしかできない
example (hP: P) (hQ: Q) (hR : R) : P ∧ Q ∧ R := by
  constructor
  · show P
    exact hP
  · show Q ∧ R
    constructor
    · show Q
      exact hQ
    · show R
      exact hR
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rel"><a class="header" href="#rel">rel</a></h1>
<p>needs: <code>import Mathlib.Tactic.GCongr</code></p>
<p>named after: 関係(relation)</p>
<p><code>rel</code> は，不等式を代入して適用し，不等式を示します．</p>
<pre><code class="language-lean">example (h1 : a ≤ b) (h2 : c ≤ d) : a + c ≤ b + d := by
  rel [h1, h2]
</code></pre>
<p><code>rel</code> は，たとえば整数 <code>x: Int</code> に対して <code>0 ≤ x ^ 2</code> であることを自動的に適用するなど, 多少の推論を行います．</p>
<pre><code class="language-lean">example (x: Int) (h1 : a ≤ b) : x ^ 2 * a ≤ x ^ 2 * b := by
  rel [h1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="replace"><a class="header" href="#replace">replace</a></h1>
<p>needs: <code>import Std.Tactic.Replace</code></p>
<p><code>replace</code> は <a href="./have.html">have</a> と同じく補題を入手するためのタクティクですが，<code>have</code> とは異なりローカルコンテキストにすでにある命題を置き換えることができます．</p>
<p><code>have</code> を使った場合，ローカルコンテキストにすでに <code>h : P</code> がある状態で，再び <code>h</code> という名前で別の命題を示すと，古い方の <code>h</code> はアクセス不能になって <code>†</code> が付いた状態になってしまいます．</p>
<p><code>replace</code> であれば，古い方が新しい方に置き換えられ，<code>†</code> の付いた命題は出現しません．</p>
<pre><code class="language-lean">example : ∀ (n : Int), Even (5 * n) → Even n := by
  intro n hn

  -- `Even (5 * n)` という仮定を分解
  obtain ⟨ k, hk ⟩ := hn

  -- 以下がローカルコンテキストに追加される
  guard_hyp hk: 5 * n = k + k

  -- `k + k` という形が使いづらいので，`2 * k` に置き換える
  replace hk : 5 * n = 2 * k := by
    rw [hk]
    ring

  -- `hk` の内容が変化している
  guard_hyp hk: 5 * n = 2 * k

  -- 計算をする
  have := by
    calc n
      _ = 5 * n - 4 * n := by ring
      _ = 2 * k - 4 * n := by rw [hk]
      _ = 2 * (k - 2 * n) := by ring

  exists k - 2 * n
  nth_rewrite 1 [this]
  ring
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfl"><a class="header" href="#rfl">rfl</a></h1>
<p>needs: <code>import Mathlib.Tactic.Relation.Rfl</code></p>
<p>named after: 反射律(reflexivity)</p>
<p><code>rfl</code> は，<code>refl attribute</code> の付けられた定理を用いて関係の反射性を示すタクティクです．</p>
<pre><code class="language-lean">inductive MyEq {α : Type u} : α → α → Prop
  | refl (a : α) : MyEq a a

attribute [refl] MyEq.refl

example (n : ℕ) : MyEq n n := by rfl
</code></pre>
<p><code>@[refl]</code> で登録された定理を用いるので，追加でライブラリを import することにより示すことができる命題が増えます．</p>
<pre><code class="language-lean">-- `import Mathlib.Data.Nat.Basic` が必要
example (n : Nat) : n ≤ n := by rfl
</code></pre>
<h2 id="補足-3"><a class="header" href="#補足-3">補足</a></h2>
<p>実は <code>Mathlib.Tactic.Relation.Rfl</code> を import するかどうかにより，内部で呼び出されるタクティクが変わります．</p>
<ul>
<li><code>Mathlib.Tactic.Relation.Rfl</code> ありなら <a href="https://leanprover-community.github.io/mathlib4_docs//Mathlib/Tactic/Relation/Rfl.html#Lean.MVarId.rfl">Lean.MVarId.rfl</a> が，</li>
<li>なしなら <a href="https://leanprover-community.github.io/mathlib4_docs//Lean/Meta/Tactic/Refl.html#Lean.MVarId.refl">Lean.MVarId.refl</a> が</li>
</ul>
<p>それぞれ参照されます．後者は <code>@[refl]</code> が付けられた一般の関係の反射性にアクセスできず，等号 <code>=</code> の反射性しか使うことができません．</p>
<p>後者の場合 <code>rfl</code> は，単に定義から等しいものが等しいことを示すタクティクになります．</p>
<pre><code class="language-lean">variable (α : Type)

example : 1 + 1 = 2 := by rfl

example (x : α) : x = x := by rfl

example : (2 ^ 70 + 3 ^ 70) % 13 = 0 := by rfl
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ring"><a class="header" href="#ring">ring</a></h1>
<p>needs: <code>import Mathlib.Tactic.Ring</code></p>
<p><code>ring</code> は，可換環の等式を示します．</p>
<pre><code class="language-lean">example : (x + y) ^ 2 = x ^ 2 + 2 * x * y + y ^ 2 := by
  ring
</code></pre>
<p><code>simp</code> 等と異なり，<code>ring?</code> タクティクは用意されていませんが，<code>show_term</code> で具体的にどんなルールが適用されたのかを知ることができます．ただし，その出力結果は非常に長く読みづらいものであることがしばしばです．例えば，</p>
<pre><code class="language-lean">example : (x + y) ^ 2 = x ^ 2 + 2 * x * y + y ^ 2 := by
  show_term ring
</code></pre>
<p>の出力をここに掲載すると100行を超えてしまいます．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rw"><a class="header" href="#rw">rw</a></h1>
<p><code>rw</code> は rewrite（書き換え）を行うタクティクです．等式や同値をもとに書き換えを行います．</p>
<p><code>hab: a = b</code> や <code>hPQ : P ↔ Q</code> がローカルコンテキストにあるとき，</p>
<ul>
<li><code>rw [hab]</code> はゴールの中の <code>a</code> をすべて <code>b</code> に置き換え，</li>
<li><code>rw [hPQ]</code> はゴールの中の <code>P</code> をすべて <code>Q</code> に置き換えます．</li>
</ul>
<p>順番は重要で，<code>b</code> を <code>a</code> に置き換えたいときなどは <code>rw [← hab]</code> のように <code>←</code> をつけます．</p>
<p><code>h1, h2, ...</code> について続けて置き換えを行いたいときは，<code>rw [h1, h2, ...]</code> のようにします．</p>
<p>ゴールではなく，ローカルコンテキストにある <code>h: P</code> を書き換えたいときには <code>at</code> をつけて <code>rw [hPQ] at h</code> とします．すべての箇所で置き換えたいときは <code>rw [hPQ] at *</code> とします．</p>
<pre><code class="language-lean">example (a b c d e f : Nat) (h : a * b = c * d) (h' : e = f) : a * (b * e) = c * (d * f) := by
  rw [h']

  -- 結合法則を使う
  rw [← Nat.mul_assoc]
  rw [h]

  -- 結合法則を使う
  rw [Nat.mul_assoc]
</code></pre>
<h2 id="nth_rewrite"><a class="header" href="#nth_rewrite">nth_rewrite</a></h2>
<p>needs: <code>import Mathlib.Tactic.NthRewrite</code></p>
<p><code>rw</code> はマッチした項をすべて置き換えてしまいます．特定の項だけを書き換えたいとき，<code>nth_rewrite</code> が使用できます．対象の式中に現れる順番を1始まりで指定することで，項を指定します．指定された順番が式中の対象の項の数よりも多い場合はエラーになります．</p>
<pre><code class="language-lean">-- `G` は群
variable [Group G]

example (a b : G) : a * b⁻¹ = 1 ↔ a = b := by
  -- `one_mul: 1 * b = b` を使って `b` を `1 * b` に書き換える
  -- `b` は2回出現するが，2番目だけ置き換える
  nth_rewrite 2 [← one_mul b]

  -- `mul_inv_eq_iff_eq_mul: a * b⁻¹ = c ↔ a = c * b` を使う
  exact mul_inv_eq_iff_eq_mul
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="says"><a class="header" href="#says">says</a></h1>
<p>needs: <code>import Mathlib.Tactic.Says</code></p>
<p><a href="./exact_question.html">exact?</a> や <a href="./apply_question.html">apply?</a> は証明を書いている過程で使用することを想定したタクティクです．<code>Try this: </code> という提案をクリックして採用したら，<code>exact?</code> や <code>apply?</code> は提案内容で上書きされて，最終的な証明には残りません．</p>
<p>では，証明のある部分が <code>apply?</code> などにより提案された内容であることを明示したい場合はどうしたら良いでしょうか？<code>says</code> タクティクはまさにその問題を解決するタクティクです．</p>
<pre><code class="language-lean">example (hPQ : P → Q) (hQR : Q → R) (hRS : R → S) (hP : P) : S := by
  -- `exact?` は実行されない
  exact? says exact hRS (hQR (hPQ hP))
</code></pre>
<p>また，<code>simp?</code> や <code>aesop?</code> などに対しても使用することができ，やはりドキュメントとして役に立ちます．</p>
<pre><code class="language-lean">-- 合成 `g ∘ f` が単射なら，`f` も単射
example {f : X → Y} {g : Y → Z} (hgfinj : Injective (g ∘ f)) : Injective f := by
  rw [Injective]
  aesop? says {
    intro a₁ a₂ a
    apply hgfinj
    simp_all only [comp_apply]
  }
</code></pre>
<h2 id="補足-4"><a class="header" href="#補足-4">補足</a></h2>
<p>より詳細には，検索タクティク <code>X</code> があり，その提案内容が <code>Try this: Y</code> だったとき，<code>X says</code> とすると <code>says</code> は <code>Try this: Y</code> の代わりに <code>Try this: X says Y</code> という提案を infoview 上で出します．それをクリックすると，<code>X says</code> の内容が <code>X says Y</code> で置換されます．そして，<code>X says Y</code> が実行されるときには <code>X</code> は飛ばされます．</p>
<p>なお，<code>X says Y</code> の <code>Y</code> のところに，実際には提案されていないタクティクを入れてもエラーにはなりません．したがって <code>X says Y</code> は，<code>X</code> の提案内容の中に <code>Try this: Y</code> があることを保証しません．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="show"><a class="header" href="#show">show</a></h1>
<p><code>show P</code> は, ゴールの中に <code>⊢ P</code> があるときにそれをメインのゴールにします．</p>
<p>たとえば，証明中にこれから示すべきことを明示し，コードを読みやすくする目的で使うことができます．</p>
<pre><code class="language-lean">example (hP: P) (hQ: Q) : P ∧ Q := by
  constructor
  · show P
    exact hP
  · show Q
    exact hQ
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simp"><a class="header" href="#simp">simp</a></h1>
<p><code>simp</code> は，ターゲットを決められた規則に基づいて自動で簡約（simplify）するタクティクです．カスタマイズすることが可能で，簡約に使ってほしい命題を登録することができます．</p>
<pre><code class="language-lean">universe u v

-- 圏の公理
class Category (C : Type u) where
  -- 射
  Hom : C → C → Type v

  -- 射の合成
  comp : ∀ {a b c : C}, Hom a b → Hom b c → Hom a c

  -- 恒等射. `id a` が `a` 上の恒等射を意味する
  id : ∀ (a : C), Hom a a

  -- 恒等射の性質
  id_comp : ∀ {a b : C} (f : Hom a b), comp (id a) f = f
  comp_id : ∀ {a b : C} (f : Hom a b), comp f (id b) = f

  -- 射の結合律
  assoc : ∀ {a b c d : C} (f : Hom a b) (g : Hom b c) (h : Hom c d),
    comp (comp f g) h = comp f (comp g h)

-- `f : Hom a b`と`g : Hom b c`の合成を`f ≫ g`と書く
infixr:80 &quot; ≫ &quot; =&gt; Category.comp

-- `Category.hoge` ではなく `hoge` で呼び出せるようにする
open Category

-- 公理の等式が `simp` で使えるようにする
attribute [simp] id_comp comp_id assoc

-- 変数の定義
variable {C : Type u} [Category.{u, v} C] {a b c d e : C}

example (f : Hom a b) (g : Hom b c) (h : Hom c d) (i : Hom d e) :
    (f ≫ (id b ≫ g)) ≫ (h ≫ i) = f ≫ (g ≫ ((id c ≫ h) ≫ i)) := by
  -- 上で `simp` で使えるようにした等式を使って自動で簡約する
  simp
</code></pre>
<p>既知の <code>h: P</code> という証明を使って簡約させたいときは，明示的に <code>simp [h]</code> と指定することで可能です．</p>
<p>何も指定しなければゴールを簡約しますが，ローカルコンテキストにある <code>h: P</code> を簡約させたければ <code>simp at h</code> と指定することで可能です．</p>
<h2 id="simp-1"><a class="header" href="#simp-1">simp?</a></h2>
<p><code>simp</code> は自動的に証明を行ってくれますが，何が使われたのか知りたいときもあります．<code>simp?</code> は簡約に何が使われたのかを示してくれるので，<code>rw</code> などを用いて明示的に書き直すことができます．</p>
<h2 id="simp_all"><a class="header" href="#simp_all">simp_all</a></h2>
<p><code>simp_all</code> は <code>simp [*] at *</code> の強化版で，ローカルコンテキストとゴールをこれ以上簡約できなくなるまですべて簡約します．</p>
<h2 id="dsimp"><a class="header" href="#dsimp">dsimp</a></h2>
<p><code>dsimp</code> は，定義上(definitionally)等しいもの同士しか簡約しないという制約付きの <code>simp</code> です．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sorry"><a class="header" href="#sorry">sorry</a></h1>
<p>証明の細部を埋める前にコンパイルが通るようにしたいとき，証明で埋めるべき箇所に <code>sorry</code> と書くとコンパイルが通るようになります．ただし，<code>sorry</code> を使用しているという旨の警告が出ます．</p>
<pre><code class="language-lean">-- Fermat の最終定理
def FermatLastTheorem :=
  ∀ x y z n : Nat, n &gt; 2 ∧ x * y * z ≠ 0 → x ^ n + y ^ n ≠ z ^ n

theorem flt : FermatLastTheorem :=
  sorry
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="suffices"><a class="header" href="#suffices">suffices</a></h1>
<p><code>suffices</code> は，数学でよくある「～を示せば十分である」という推論を行うタクティクです．</p>
<p>ゴールが <code>⊢ P</code> であるときに <code>suffices Q from</code> を実行すると，</p>
<ul>
<li><code>suffices Q from</code> のブロック内では，仮定に <code>this: Q</code> が追加され，</li>
<li><code>suffices Q from</code> 以降では，ゴールが <code>⊢ Q</code> に書き換えられます．</li>
</ul>
<p><code>apply</code> と似ていますが，<code>apply</code> と違って「十分条件になっていること」の証明が明らかでないときにも使うことができます．</p>
<pre><code class="language-lean">example : 13 ∣ (2 ^ 70 + 3 ^ 70) := by
  -- 余りがゼロであることを示せば十分
  suffices (2 ^ 70 + 3 ^ 70) % 13 = 0 from by
    exact Iff.mpr (Nat.dvd_iff_div_mul_eq (2 ^ 70 + 3 ^ 70) 13) rfl

  rfl
</code></pre>
<p><code>suffices Q from ...</code> という形式の場合は，証明を直接構成することが必要です．<code>suffices Q from by ...</code> とすると，タクティクによって証明を構成するモードになります．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trivial"><a class="header" href="#trivial">trivial</a></h1>
<p><code>trivial</code> は明らかなことを示します．</p>
<p><code>trivial</code> は，<code>rfl</code> や <code>contradiction</code> などのタクティクを実行して，現在のゴールを閉じようとします．</p>
<pre><code class="language-lean">-- 定義から明らかな等式
example : 1 + 1 = 2 := by trivial

-- 矛盾があるので, どんな命題でも証明できる
example (h: False) : P := by trivial
</code></pre>
<p>普段の数学でいう「自明」な命題は <code>trivial</code> では示せないことがほとんどだと思います．<a href="./aesop.html">aesop</a> を試してみてください．</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="highlight.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
